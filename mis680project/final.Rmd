---
title: "Enron Emails Analysis"
author: "Vivek Ghelani and Koba Khitalishvili Group 8"
date: "June 6, 2016"
output: html_document
---

# Prerequisites
  - Packages: ndtv, networkD3, igraph and animation
  - Additional software: [ImageMagick](http://www.imagemagick.org/script/index.php) for animations
  - python for mapreduce

# Intro

Below are the files we obtained using mapreduce and hadoop. It was enough to have one main mapper and
reducer. We focused on sent and recieved emails over the period May 1999 and July 2001. Enron declared bankruptcy in December 2001 and the scandal started in November. We would like to observe the Enron Email Network up to the point where the internal community of Enron started suffering from fraudulent practices.


# Look at the data

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, comment = FALSE, fig.align = "center", fig.height = 8, fig.width = 10) 
```

```{r, results='asis'}
dir("data")
# read data in
dat = read.delim("data/sent-emails-long.txt", colClasses = 'character')
names(dat) = c('date', 'sender', 'reciever', 'email_id')

# explore
head(dat)
summary(dat)

# leave only those connections that are employees
dat = dat[dat$reciever %in% unique(dat$sender),]
dat = dat[dat$sender %in% unique(dat$reciever),]
# length(union(dat$sender,dat$reciever))
# nrow(dat)

# add year month column
dat$yearm = as.numeric(substr(gsub("\\-","",dat$date),1,6))
dat = dat[dat$yearm >19000,]
```

```{r}
# necessary packages
# install.packages("ndtv", "networkD3", "igraph", dependencies=T)
# install.packages('animation')

library(igraph)

# edges
links = dat[,c("sender","reciever", "yearm")]
links = links[order(links$yearm),]

# nodes
nodes = base::union(links$sender,links$reciever)

# net
net = graph.data.frame(links, nodes, directed=F)

# plot network
l = layout.fruchterman.reingold(net)
plot(net,
     rescale = F,
     layout = l*0.2)

# add colors
V(net)$community <- optimal.community(net)$membership

plot(net, 
     vertex.color = V(net)$community,
     layout = l*0.25)
```

# Interactive graphs

```{r}
library(networkD3)

data(MisLinks)
data(MisNodes)

d3nodes = data.frame(name = names(V(net)),group = V(net)$community)
d3nodes$id = rownames(d3nodes)
d3nodes = d3nodes[order(d3nodes$id),]

d3links = data.frame(
  sender = sapply(links$sender, function(x) d3nodes[d3nodes$name == x,"id"]),
  reciever = sapply(links$reciever, function(x) d3nodes[d3nodes$name == x,"id"]),
  value = 5)

d3links = d3links[order(d3links$sender,d3links$reciever),]

forceNetwork(Links = d3links, Nodes = d3nodes,
            Source = "sender", Target = "reciever",
            NodeID = "id", Value = "value",
            Group = "group", opacity = 0.8)
```

# Dynamic social networks

```{r, fig.width=8}
# Dynamic networks
library(ndtv)
library(animation)
library(network)

# check whether animation got the path for ImageMagic right
ani.options(convert="C:\\Program Files\\ImageMagick-7.0.1-Q16\\convert.exe") 
#ani.options("convert")

# prepare the time points
links.dyn = links[!duplicated(links[,1]),] 
links.dyn$onset = sapply(links.dyn$yearm, function(x) which(unique(links.dyn[,3]) == x)-1)

nodes = links.dyn[,1]
nodes = base::union(nodes,links.dyn[,2])
names(nodes) = nodes


net2 <- network(links.dyn[,1:2], 
                # vertex.attr=names(nodes), 
                matrix.type="edgelist", 
                loops=F, multiple=F, ignore.eval = F)

par(mfrow = c(1,2))
plot(net2, main = "Enron network in the last period")

terminus = length(unique(links.dyn$yearm)) # point at which nodes and edges dissipate
onset.es = links.dyn$onset # list of time points at which edges appear


# vertices
vs <- data.frame(onset=0, 
                 terminus=terminus, 
                 vertex.id=1:length(nodes))
# edges
es <- data.frame(onset=onset.es, 
                 terminus=terminus, 
                 head=as.matrix(net2, matrix.type="edgelist")[,1],
                 tail=as.matrix(net2, matrix.type="edgelist")[,2])

net2.dyn <- networkDynamic(base.net=net2, edge.spells=es, vertex.spells=vs)

plot( network.extract(net2.dyn, at=0) ,  main = 'Enron Network in the  starting period')
par(mfrow = c(1,1))

# plot(net2.dyn)
```


### Enron network in strips

```{r, fig.width=8}
filmstrip(net2.dyn, displaylabels=F, mfrow=c(2, 5),
          slice.par=list(start=0, end=terminus, interval=6, 
                         aggregate.dur=6, rule='any'))
```

### Enron Network over time

```{r}
compute.animation(net2.dyn, animation.mode = "kamadakawai",
                  slice.par=list(start=0, end=terminus, interval=2, 
                         aggregate.dur=2, rule='any'))

render.d3movie(net2.dyn,displaylabels=TRUE, output.mode = 'htmlWidget') 
```

```{r}
# Time Prism
compute.animation(net2.dyn)

timePrism(net2.dyn,at=c(1,10,terminus-1),
          displaylabels=TRUE,planes = TRUE,
          label.cex=0.5,
          main = "Time Prism of the Enron Network")
```

```{r}
# stats
library(tsna)

plot(tEdgeFormation(net2.dyn), main = "Edge formation by period", 
     xlab = "Count of edges", ylab = "Time period")

# clique.census(net2, mode = "digraph")

```

> The computational cost of calculating cliques grows very sharply in size and network density. It is possible that the expected completion time for your calculation may exceed your life expectancy (and those of subsequent generations).